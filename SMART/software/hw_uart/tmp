
hw_uart.elf:     file format elf32-msp430


Disassembly of section __interrupt_vector_8:

0000ffee <__interrupt_vector_8>:
    ffee:	6c e1       	interrupt service routine at 0xe16c

Disassembly of section .text:

0000e028 <__crt0_start>:
    e028:	31 40 00 06 	mov	#1536,	r1	;#0x0600

0000e02c <__crt0_init_bss>:
    e02c:	3c 40 02 02 	mov	#514,	r12	;#0x0202

0000e030 <.Loc.74.1>:
    e030:	0d 43       	clr	r13		;

0000e032 <.Loc.75.1>:
    e032:	3e 40 13 00 	mov	#19,	r14	;#0x0013

0000e036 <.Loc.79.1>:
    e036:	b0 12 d4 e9 	call	#59860		;#0xe9d4

0000e03a <__crt0_movedata>:
    e03a:	3c 40 00 02 	mov	#512,	r12	;#0x0200

0000e03e <.Loc.116.1>:
    e03e:	3d 40 20 ea 	mov	#59936,	r13	;#0xea20

0000e042 <.Loc.119.1>:
    e042:	0d 9c       	cmp	r12,	r13	;

0000e044 <.Loc.120.1>:
    e044:	04 24       	jz	$+10     	;abs 0xe04e

0000e046 <.Loc.122.1>:
    e046:	3e 40 02 00 	mov	#2,	r14	;

0000e04a <.Loc.124.1>:
    e04a:	b0 12 9c e9 	call	#59804		;#0xe99c

0000e04e <__crt0_call_init_then_main>:
    e04e:	b0 12 04 ea 	call	#59908		;#0xea04

0000e052 <.Loc.196.1>:
    e052:	0c 43       	clr	r12		;

0000e054 <.Loc.197.1>:
    e054:	b0 12 c0 e1 	call	#57792		;#0xe1c0

0000e058 <_msp430_run_init_array>:
    e058:	34 40 1c e0 	mov	#57372,	r4	;#0xe01c

0000e05c <.Loc.224.1>:
    e05c:	35 40 1c e0 	mov	#57372,	r5	;#0xe01c

0000e060 <.Loc.225.1>:
    e060:	26 43       	mov	#2,	r6	;r3 As==10

0000e062 <.Loc.226.1>:
    e062:	30 40 84 e0 	br	#0xe084		;

0000e066 <_msp430_run_preinit_array>:
    e066:	34 40 1c e0 	mov	#57372,	r4	;#0xe01c

0000e06a <.Loc.232.1>:
    e06a:	35 40 1c e0 	mov	#57372,	r5	;#0xe01c

0000e06e <.Loc.233.1>:
    e06e:	26 43       	mov	#2,	r6	;r3 As==10

0000e070 <.Loc.234.1>:
    e070:	30 40 84 e0 	br	#0xe084		;

0000e074 <_msp430_run_fini_array>:
    e074:	34 40 1c e0 	mov	#57372,	r4	;#0xe01c

0000e078 <.Loc.240.1>:
    e078:	35 40 1c e0 	mov	#57372,	r5	;#0xe01c

0000e07c <.Loc.241.1>:
    e07c:	36 40 fe ff 	mov	#65534,	r6	;#0xfffe

0000e080 <.Loc.242.1>:
    e080:	30 40 84 e0 	br	#0xe084		;

0000e084 <_msp430_run_array>:
    e084:	05 94       	cmp	r4,	r5	;

0000e086 <.Loc.246.1>:
    e086:	05 24       	jz	$+12     	;abs 0xe092

0000e088 <.Loc.247.1>:
    e088:	27 44       	mov	@r4,	r7	;

0000e08a <.Loc.248.1>:
    e08a:	04 56       	add	r6,	r4	;

0000e08c <.Loc.249.1>:
    e08c:	a7 12       	call	@r7		;

0000e08e <.Loc.250.1>:
    e08e:	10 40 f4 ff 	br	0xfff4		;PC rel. 0xe084

0000e092 <_msp430_run_done>:
    e092:	30 41       	ret			

0000e094 <L0>:
    e094:	30 41       	ret			
    e096:	30 41       	ret			

0000e098 <deregister_tm_clones>:
    e098:	3c 40 20 ea 	mov	#59936,	r12	;#0xea20
    e09c:	3c 90 20 ea 	cmp	#59936,	r12	;#0xea20
    e0a0:	07 24       	jz	$+16     	;abs 0xe0b0
    e0a2:	3d 40 00 00 	mov	#0,	r13	;
    e0a6:	0d 93       	cmp	#0,	r13	;r3 As==00
    e0a8:	03 24       	jz	$+8      	;abs 0xe0b0
    e0aa:	3c 40 20 ea 	mov	#59936,	r12	;#0xea20
    e0ae:	8d 12       	call	r13		;

0000e0b0 <.L1>:
    e0b0:	30 41       	ret			

0000e0b2 <register_tm_clones>:
    e0b2:	0a 12       	push	r10		;
    e0b4:	3a 40 20 ea 	mov	#59936,	r10	;#0xea20
    e0b8:	3a 80 20 ea 	sub	#59936,	r10	;#0xea20
    e0bc:	0a 11       	rra	r10		;
    e0be:	0c 4a       	mov	r10,	r12	;
    e0c0:	b0 12 e8 e8 	call	#59624		;#0xe8e8
    e0c4:	0c 5a       	add	r10,	r12	;
    e0c6:	0d 4c       	mov	r12,	r13	;
    e0c8:	0d 11       	rra	r13		;
    e0ca:	0d 93       	cmp	#0,	r13	;r3 As==00
    e0cc:	07 24       	jz	$+16     	;abs 0xe0dc
    e0ce:	3e 40 00 00 	mov	#0,	r14	;
    e0d2:	0e 93       	cmp	#0,	r14	;r3 As==00
    e0d4:	03 24       	jz	$+8      	;abs 0xe0dc
    e0d6:	3c 40 20 ea 	mov	#59936,	r12	;#0xea20
    e0da:	8e 12       	call	r14		;

0000e0dc <.L9>:
    e0dc:	3a 41       	pop	r10		;
    e0de:	30 41       	ret			

0000e0e0 <__do_global_dtors_aux>:
    e0e0:	0a 12       	push	r10		;
    e0e2:	09 12       	push	r9		;
    e0e4:	c2 93 02 02 	cmp.b	#0,	&0x0202	;r3 As==00
    e0e8:	17 20       	jnz	$+48     	;abs 0xe118
    e0ea:	3a 40 26 e0 	mov	#57382,	r10	;#0xe026
    e0ee:	3a 80 24 e0 	sub	#57380,	r10	;#0xe024
    e0f2:	0a 11       	rra	r10		;
    e0f4:	3a 53       	add	#-1,	r10	;r3 As==11
    e0f6:	39 40 24 e0 	mov	#57380,	r9	;#0xe024

0000e0fa <.L19>:
    e0fa:	1c 42 04 02 	mov	&0x0204,r12	;0x0204
    e0fe:	0c 9a       	cmp	r10,	r12	;
    e100:	0d 28       	jnc	$+28     	;abs 0xe11c
    e102:	b0 12 98 e0 	call	#57496		;#0xe098
    e106:	3d 40 00 00 	mov	#0,	r13	;
    e10a:	0d 93       	cmp	#0,	r13	;r3 As==00
    e10c:	03 24       	jz	$+8      	;abs 0xe114
    e10e:	3c 40 18 e0 	mov	#57368,	r12	;#0xe018
    e112:	8d 12       	call	r13		;

0000e114 <.L21>:
    e114:	d2 43 02 02 	mov.b	#1,	&0x0202	;r3 As==01

0000e118 <.L17>:
    e118:	30 40 6e e8 	br	#0xe86e		;

0000e11c <.L20>:
    e11c:	1c 53       	inc	r12		;
    e11e:	82 4c 04 02 	mov	r12,	&0x0204	;
    e122:	0c 5c       	rla	r12		;
    e124:	0c 59       	add	r9,	r12	;
    e126:	2c 4c       	mov	@r12,	r12	;
    e128:	8c 12       	call	r12		;
    e12a:	30 40 fa e0 	br	#0xe0fa		;

0000e12e <call___do_global_dtors_aux>:
    e12e:	3e 40 00 00 	mov	#0,	r14	;
    e132:	0e 93       	cmp	#0,	r14	;r3 As==00
    e134:	05 24       	jz	$+12     	;abs 0xe140
    e136:	3d 40 06 02 	mov	#518,	r13	;#0x0206
    e13a:	3c 40 18 e0 	mov	#57368,	r12	;#0xe018
    e13e:	8e 12       	call	r14		;

0000e140 <.L27>:
    e140:	b0 12 b2 e0 	call	#57522		;#0xe0b2
    e144:	30 41       	ret			

0000e146 <delay>:

//--------------------------------------------------//
//                   Delay function                 //
//--------------------------------------------------//
void delay(unsigned int d) {
   while(d--) {
    e146:	0d 4c       	mov	r12,	r13	;
    e148:	3d 53       	add	#-1,	r13	;r3 As==11

0000e14a <.LVL1>:
    e14a:	0c 93       	cmp	#0,	r12	;r3 As==00
    e14c:	05 24       	jz	$+12     	;abs 0xe158

0000e14e <.L3>:
      __nop();
    e14e:	03 43       	nop			

0000e150 <.Loc.13.1>:
      __nop();
    e150:	03 43       	nop			

0000e152 <.Loc.11.1>:

//--------------------------------------------------//
//                   Delay function                 //
//--------------------------------------------------//
void delay(unsigned int d) {
   while(d--) {
    e152:	3d 53       	add	#-1,	r13	;r3 As==11
    e154:	3d 93       	cmp	#-1,	r13	;r3 As==11
    e156:	fb 23       	jnz	$-8      	;abs 0xe14e

0000e158 <.L1>:
      __nop();
      __nop();
   }
}
    e158:	30 41       	ret			

0000e15a <tty_putc>:
//            (Send a byte to the UART)             //
//--------------------------------------------------//
int tty_putc (int txdata) {

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    e15a:	7d 40 81 00 	mov.b	#129,	r13	;#0x0081

0000e15e <.L10>:
    e15e:	fd b2 00 00 	bit.b	#8,	0(r13)	;r2 As==11
    e162:	fd 23       	jnz	$-4      	;abs 0xe15e

0000e164 <.Loc.27.1>:

  // Write the output character
  UART_TXD = txdata;
    e164:	c2 4c 84 00 	mov.b	r12,	&0x0084	;

0000e168 <.Loc.30.1>:

  return 0;
}
    e168:	4c 43       	clr.b	r12		;

0000e16a <.LVL4>:
    e16a:	30 41       	ret			

0000e16c <INT_uart_rx>:
//         (receive a byte from the UART)           //
//--------------------------------------------------//
volatile char rxdata;

// wakeup interrupt (8) INT_uart_rx(void) {
interrupt (8) INT_uart_rx(void) {
    e16c:	0f 12       	push	r15		;

0000e16e <.LCFI0>:
    e16e:	0e 12       	push	r14		;

0000e170 <.LCFI1>:
    e170:	0d 12       	push	r13		;

0000e172 <.LCFI2>:
    e172:	0c 12       	push	r12		;

0000e174 <.LCFI3>:
    e174:	0b 12       	push	r11		;

0000e176 <.LCFI4>:
    e176:	0a 12       	push	r10		;

0000e178 <.LCFI5>:
    e178:	09 12       	push	r9		;

0000e17a <.LCFI6>:
    e17a:	08 12       	push	r8		;

0000e17c <.LCFI7>:
    e17c:	07 12       	push	r7		;

0000e17e <.LCFI8>:
    e17e:	06 12       	push	r6		;

0000e180 <.LCFI9>:
    e180:	05 12       	push	r5		;

0000e182 <.LCFI10>:
    e182:	04 12       	push	r4		;

0000e184 <.LCFI11>:
    e184:	21 82       	sub	#4,	r1	;r2 As==10

0000e186 <.LCFI12>:
  // Read the received data
  rxdata = UART_RXD;
    e186:	d2 42 85 00 	mov.b	&0x0085,&0x0214	;0x0085
    e18a:	14 02 

0000e18c <.Loc.44.1>:

  // Clear the receive pending flag
  UART_STAT = UART_RX_PND;
    e18c:	f2 40 10 00 	mov.b	#16,	&0x0081	;#0x0010
    e190:	81 00 

0000e192 <.Loc.46.1>:

  cprintf("%c", rxdata);
    e192:	5c 42 14 02 	mov.b	&0x0214,r12	;0x0214
    e196:	81 4c 02 00 	mov	r12,	2(r1)	;
    e19a:	b1 40 00 e0 	mov	#57344,	0(r1)	;#0xe000
    e19e:	00 00 
    e1a0:	b0 12 a2 e5 	call	#58786		;#0xe5a2

0000e1a4 <.LVL5>:
  // // Exit the low power mode
  // LPM0_EXIT;
}
    e1a4:	21 52       	add	#4,	r1	;r2 As==10
    e1a6:	34 41       	pop	r4		;
    e1a8:	35 41       	pop	r5		;
    e1aa:	36 41       	pop	r6		;
    e1ac:	37 41       	pop	r7		;
    e1ae:	38 41       	pop	r8		;
    e1b0:	39 41       	pop	r9		;
    e1b2:	3a 41       	pop	r10		;
    e1b4:	3b 41       	pop	r11		;
    e1b6:	3c 41       	pop	r12		;
    e1b8:	3d 41       	pop	r13		;
    e1ba:	3e 41       	pop	r14		;
    e1bc:	3f 41       	pop	r15		;
    e1be:	00 13       	reti			

0000e1c0 <main>:
//--------------------------------------------------//
// Main function with init an an endless loop that  //
// is synced with the interrupts trough the         //
// lowpower mode.                                   //
//--------------------------------------------------//
int main(void) {
    e1c0:	21 83       	decd	r1		;

0000e1c2 <.LCFI13>:
    char buf[40];
    int led = 0;
//    int *key;
//    key = (void *)0xfee0; 

    WDTCTL = WDTPW | WDTHOLD;           // Init watchdog timer
    e1c2:	b2 40 80 5a 	mov	#23168,	&0x0120	;#0x5a80
    e1c6:	20 01 

0000e1c8 <.Loc.72.1>:

    P3DIR  = 0xff;
    e1c8:	f2 43 1a 00 	mov.b	#-1,	&0x001a	;r3 As==11

0000e1cc <.Loc.73.1>:
    P3OUT  = 0xff;                      // Light LED during init
    e1cc:	f2 43 19 00 	mov.b	#-1,	&0x0019	;r3 As==11

0000e1d0 <.Loc.75.1>:

    UART_BAUD = BAUD;                   // Init UART
    e1d0:	b2 40 ae 00 	mov	#174,	&0x0082	;#0x00ae
    e1d4:	82 00 

0000e1d6 <.Loc.76.1>:
    UART_CTL  = UART_EN | UART_IEN_RX;
    e1d6:	f2 40 11 00 	mov.b	#17,	&0x0080	;#0x0011
    e1da:	80 00 

0000e1dc <.Loc.81.1>:


    // delay(65535);

    P3OUT  = 0x00;                      // Switch off LED
    e1dc:	c2 43 19 00 	mov.b	#0,	&0x0019	;r3 As==00

0000e1e0 <.Loc.84.1>:

    // cprintf("\r\n====== openMSP430 in action ======\r\n");   //say hello
    cprintf("> ");
    e1e0:	b1 40 03 e0 	mov	#57347,	0(r1)	;#0xe003
    e1e4:	00 00 
    e1e6:	b0 12 a2 e5 	call	#58786		;#0xe5a2

0000e1ea <.LVL7>:
  //  cprintf("%d", *key);

    enable_interrupts();                  // Enable interrupts
    e1ea:	03 43       	nop			
    e1ec:	32 d2       	eint			
    e1ee:	03 43       	nop			

0000e1f0 <.L14>:
    e1f0:	30 40 f0 e1 	br	#0xe1f0		;

0000e1f4 <cput_nibble>:


void
cput_nibble (int n)
{
  tty_putc (hex[n&0x0f]);
    e1f4:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f

0000e1f8 <.LVL1>:
    e1f8:	5d 4c 06 e0 	mov.b	-8186(r12),r13	;0xffffe006

0000e1fc <.LBB120>:
//            (Send a byte to the UART)             //
//--------------------------------------------------//
static int tty_putc (int txdata) {

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    e1fc:	7c 40 81 00 	mov.b	#129,	r12	;#0x0081

0000e200 <.L2>:
    e200:	fc b2 00 00 	bit.b	#8,	0(r12)	;r2 As==11
    e204:	fd 23       	jnz	$-4      	;abs 0xe200

0000e206 <.Loc.20.1>:

  // Write the output character
  UART_TXD = txdata;
    e206:	c2 4d 84 00 	mov.b	r13,	&0x0084	;

0000e20a <.LBE120>:

void
cput_nibble (int n)
{
  tty_putc (hex[n&0x0f]);
}
    e20a:	30 41       	ret			

0000e20c <cput_hex_byte>:

void
cput_hex_byte (int n)
{
    e20c:	0a 12       	push	r10		;

0000e20e <.LCFI0>:
    e20e:	09 12       	push	r9		;

0000e210 <.LCFI1>:
    e210:	09 4c       	mov	r12,	r9	;

0000e212 <.LBB122>:


void
cput_nibble (int n)
{
  tty_putc (hex[n&0x0f]);
    e212:	3a 40 06 e0 	mov	#57350,	r10	;#0xe006

0000e216 <.LBE122>:
}

void
cput_hex_byte (int n)
{
  cput_nibble (n >> 4);
    e216:	b0 12 8a e8 	call	#59530		;#0xe88a

0000e21a <.LBB127>:


void
cput_nibble (int n)
{
  tty_putc (hex[n&0x0f]);
    e21a:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    e21e:	0c 5a       	add	r10,	r12	;
    e220:	6d 4c       	mov.b	@r12,	r13	;

0000e222 <.LBB124>:
//            (Send a byte to the UART)             //
//--------------------------------------------------//
static int tty_putc (int txdata) {

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    e222:	7c 40 81 00 	mov.b	#129,	r12	;#0x0081

0000e226 <.L6>:
    e226:	fc b2 00 00 	bit.b	#8,	0(r12)	;r2 As==11
    e22a:	fd 23       	jnz	$-4      	;abs 0xe226

0000e22c <.Loc.20.1>:

  // Write the output character
  UART_TXD = txdata;
    e22c:	c2 4d 84 00 	mov.b	r13,	&0x0084	;

0000e230 <.LBB128>:


void
cput_nibble (int n)
{
  tty_putc (hex[n&0x0f]);
    e230:	79 f0 0f 00 	and.b	#15,	r9	;#0x000f

0000e234 <.LVL9>:
    e234:	0a 59       	add	r9,	r10	;
    e236:	6d 4a       	mov.b	@r10,	r13	;

0000e238 <.LBB130>:
//            (Send a byte to the UART)             //
//--------------------------------------------------//
static int tty_putc (int txdata) {

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    e238:	7c 40 81 00 	mov.b	#129,	r12	;#0x0081

0000e23c <.L7>:
    e23c:	fc b2 00 00 	bit.b	#8,	0(r12)	;r2 As==11
    e240:	fd 23       	jnz	$-4      	;abs 0xe23c

0000e242 <.Loc.20.1>:

  // Write the output character
  UART_TXD = txdata;
    e242:	c2 4d 84 00 	mov.b	r13,	&0x0084	;

0000e246 <.LBE128>:
void
cput_hex_byte (int n)
{
  cput_nibble (n >> 4);
  cput_nibble (n);
}
    e246:	30 40 6e e8 	br	#0xe86e		;

0000e24a <cput_binary_byte>:

void
cput_binary_byte (int n)
{
    e24a:	0a 12       	push	r10		;

0000e24c <.LCFI2>:
    e24c:	09 12       	push	r9		;

0000e24e <.LCFI3>:
    e24e:	08 12       	push	r8		;

0000e250 <.LCFI4>:
    e250:	07 12       	push	r7		;

0000e252 <.LCFI5>:
    e252:	06 12       	push	r6		;

0000e254 <.LCFI6>:
    e254:	05 12       	push	r5		;

0000e256 <.LCFI7>:
    e256:	07 4c       	mov	r12,	r7	;

0000e258 <.LVL13>:
  int i;
  for (i=7; i>=0; i--)
    e258:	79 40 07 00 	mov.b	#7,	r9	;
    e25c:	75 40 30 00 	mov.b	#48,	r5	;#0x0030

0000e260 <.Loc.44.1>:
    tty_putc((n & (1<<i)) ? '1' : '0');
    e260:	76 40 31 00 	mov.b	#49,	r6	;#0x0031

0000e264 <.LBB132>:
//            (Send a byte to the UART)             //
//--------------------------------------------------//
static int tty_putc (int txdata) {

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    e264:	7a 40 81 00 	mov.b	#129,	r10	;#0x0081

0000e268 <.Loc.20.1>:

  // Write the output character
  UART_TXD = txdata;
    e268:	78 40 84 00 	mov.b	#132,	r8	;#0x0084

0000e26c <.L13>:
void
cput_binary_byte (int n)
{
  int i;
  for (i=7; i>=0; i--)
    tty_putc((n & (1<<i)) ? '1' : '0');
    e26c:	0c 47       	mov	r7,	r12	;
    e26e:	0d 49       	mov	r9,	r13	;
    e270:	b0 12 98 e8 	call	#59544		;#0xe898
    e274:	1c b3       	bit	#1,	r12	;r3 As==01
    e276:	0b 24       	jz	$+24     	;abs 0xe28e
    e278:	0c 46       	mov	r6,	r12	;

0000e27a <.L12>:
//            (Send a byte to the UART)             //
//--------------------------------------------------//
static int tty_putc (int txdata) {

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    e27a:	fa b2 00 00 	bit.b	#8,	0(r10)	;r2 As==11
    e27e:	fd 23       	jnz	$-4      	;abs 0xe27a

0000e280 <.L17>:

  // Write the output character
  UART_TXD = txdata;
    e280:	c8 4c 00 00 	mov.b	r12,	0(r8)	;

0000e284 <.LBE136>:

void
cput_binary_byte (int n)
{
  int i;
  for (i=7; i>=0; i--)
    e284:	39 53       	add	#-1,	r9	;r3 As==11
    e286:	39 93       	cmp	#-1,	r9	;r3 As==11
    e288:	f1 23       	jnz	$-28     	;abs 0xe26c

0000e28a <.Loc.45.1>:
    tty_putc((n & (1<<i)) ? '1' : '0');
}
    e28a:	30 40 66 e8 	br	#0xe866		;

0000e28e <.L14>:
    e28e:	0c 45       	mov	r5,	r12	;

0000e290 <.LBB137>:
//            (Send a byte to the UART)             //
//--------------------------------------------------//
static int tty_putc (int txdata) {

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    e290:	fa b2 00 00 	bit.b	#8,	0(r10)	;r2 As==11
    e294:	f2 23       	jnz	$-26     	;abs 0xe27a
    e296:	30 40 80 e2 	br	#0xe280		;

0000e29a <cput_hex_word>:
    tty_putc((n & (1<<i)) ? '1' : '0');
}

void
cput_hex_word (int n)
{
    e29a:	0a 12       	push	r10		;

0000e29c <.LCFI8>:
    e29c:	09 12       	push	r9		;

0000e29e <.LCFI9>:
    e29e:	08 12       	push	r8		;

0000e2a0 <.LCFI10>:
    e2a0:	09 4c       	mov	r12,	r9	;

0000e2a2 <.Loc.50.1>:
  cput_hex_byte (n >> 8);
    e2a2:	b0 12 82 e8 	call	#59522		;#0xe882

0000e2a6 <.LVL18>:
    e2a6:	08 4c       	mov	r12,	r8	;

0000e2a8 <.LBB138>:


void
cput_nibble (int n)
{
  tty_putc (hex[n&0x0f]);
    e2a8:	3a 40 06 e0 	mov	#57350,	r10	;#0xe006
    e2ac:	0c 49       	mov	r9,	r12	;
    e2ae:	b0 12 f4 e8 	call	#59636		;#0xe8f4
    e2b2:	0c 5a       	add	r10,	r12	;
    e2b4:	6d 4c       	mov.b	@r12,	r13	;

0000e2b6 <.LBB141>:
//            (Send a byte to the UART)             //
//--------------------------------------------------//
static int tty_putc (int txdata) {

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    e2b6:	7c 40 81 00 	mov.b	#129,	r12	;#0x0081

0000e2ba <.L19>:
    e2ba:	fc b2 00 00 	bit.b	#8,	0(r12)	;r2 As==11
    e2be:	fd 23       	jnz	$-4      	;abs 0xe2ba

0000e2c0 <.Loc.20.1>:

  // Write the output character
  UART_TXD = txdata;
    e2c0:	c2 4d 84 00 	mov.b	r13,	&0x0084	;

0000e2c4 <.LBB143>:


void
cput_nibble (int n)
{
  tty_putc (hex[n&0x0f]);
    e2c4:	78 f0 0f 00 	and.b	#15,	r8	;#0x000f

0000e2c8 <.LVL23>:
    e2c8:	08 5a       	add	r10,	r8	;
    e2ca:	6d 48       	mov.b	@r8,	r13	;

0000e2cc <.LBB145>:
//            (Send a byte to the UART)             //
//--------------------------------------------------//
static int tty_putc (int txdata) {

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    e2cc:	7c 40 81 00 	mov.b	#129,	r12	;#0x0081

0000e2d0 <.L20>:
    e2d0:	fc b2 00 00 	bit.b	#8,	0(r12)	;r2 As==11
    e2d4:	fd 23       	jnz	$-4      	;abs 0xe2d0

0000e2d6 <.Loc.20.1>:

  // Write the output character
  UART_TXD = txdata;
    e2d6:	c2 4d 84 00 	mov.b	r13,	&0x0084	;

0000e2da <.LBB147>:
}

void
cput_hex_byte (int n)
{
  cput_nibble (n >> 4);
    e2da:	0c 49       	mov	r9,	r12	;
    e2dc:	b0 12 8a e8 	call	#59530		;#0xe88a

0000e2e0 <.LBB149>:


void
cput_nibble (int n)
{
  tty_putc (hex[n&0x0f]);
    e2e0:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    e2e4:	0c 5a       	add	r10,	r12	;
    e2e6:	6d 4c       	mov.b	@r12,	r13	;

0000e2e8 <.LBB151>:
//            (Send a byte to the UART)             //
//--------------------------------------------------//
static int tty_putc (int txdata) {

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    e2e8:	7c 40 81 00 	mov.b	#129,	r12	;#0x0081

0000e2ec <.L21>:
    e2ec:	fc b2 00 00 	bit.b	#8,	0(r12)	;r2 As==11
    e2f0:	fd 23       	jnz	$-4      	;abs 0xe2ec

0000e2f2 <.Loc.20.1>:

  // Write the output character
  UART_TXD = txdata;
    e2f2:	c2 4d 84 00 	mov.b	r13,	&0x0084	;

0000e2f6 <.LBB153>:


void
cput_nibble (int n)
{
  tty_putc (hex[n&0x0f]);
    e2f6:	79 f0 0f 00 	and.b	#15,	r9	;#0x000f

0000e2fa <.LVL29>:
    e2fa:	0a 59       	add	r9,	r10	;
    e2fc:	6d 4a       	mov.b	@r10,	r13	;

0000e2fe <.LBB155>:
//            (Send a byte to the UART)             //
//--------------------------------------------------//
static int tty_putc (int txdata) {

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    e2fe:	7c 40 81 00 	mov.b	#129,	r12	;#0x0081

0000e302 <.L22>:
    e302:	fc b2 00 00 	bit.b	#8,	0(r12)	;r2 As==11
    e306:	fd 23       	jnz	$-4      	;abs 0xe302

0000e308 <.Loc.20.1>:

  // Write the output character
  UART_TXD = txdata;
    e308:	c2 4d 84 00 	mov.b	r13,	&0x0084	;

0000e30c <.LBE147>:
void
cput_hex_word (int n)
{
  cput_hex_byte (n >> 8);
  cput_hex_byte (n);
}
    e30c:	30 40 6c e8 	br	#0xe86c		;

0000e310 <cput_hex_long>:

void
cput_hex_long (long int n)
{
    e310:	0a 12       	push	r10		;

0000e312 <.LCFI11>:
    e312:	09 12       	push	r9		;

0000e314 <.LCFI12>:
    e314:	08 12       	push	r8		;

0000e316 <.LCFI13>:
    e316:	07 12       	push	r7		;

0000e318 <.LCFI14>:
    e318:	09 4c       	mov	r12,	r9	;
    e31a:	08 4d       	mov	r13,	r8	;

0000e31c <.Loc.57.1>:
  cput_hex_byte (n >> 24);
    e31c:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    e320:	b0 12 e2 e8 	call	#59618		;#0xe8e2

0000e324 <.LVL33>:
    e324:	07 4c       	mov	r12,	r7	;

0000e326 <.LBB157>:


void
cput_nibble (int n)
{
  tty_putc (hex[n&0x0f]);
    e326:	3a 40 06 e0 	mov	#57350,	r10	;#0xe006

0000e32a <.LBE159>:
}

void
cput_hex_byte (int n)
{
  cput_nibble (n >> 4);
    e32a:	b0 12 8a e8 	call	#59530		;#0xe88a

0000e32e <.LBB164>:


void
cput_nibble (int n)
{
  tty_putc (hex[n&0x0f]);
    e32e:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    e332:	0c 5a       	add	r10,	r12	;
    e334:	6d 4c       	mov.b	@r12,	r13	;

0000e336 <.LBB161>:
//            (Send a byte to the UART)             //
//--------------------------------------------------//
static int tty_putc (int txdata) {

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    e336:	7c 40 81 00 	mov.b	#129,	r12	;#0x0081

0000e33a <.L28>:
    e33a:	fc b2 00 00 	bit.b	#8,	0(r12)	;r2 As==11
    e33e:	fd 23       	jnz	$-4      	;abs 0xe33a

0000e340 <.Loc.20.1>:

  // Write the output character
  UART_TXD = txdata;
    e340:	c2 4d 84 00 	mov.b	r13,	&0x0084	;

0000e344 <.LBB165>:


void
cput_nibble (int n)
{
  tty_putc (hex[n&0x0f]);
    e344:	77 f0 0f 00 	and.b	#15,	r7	;#0x000f

0000e348 <.LVL38>:
    e348:	07 5a       	add	r10,	r7	;
    e34a:	6d 47       	mov.b	@r7,	r13	;

0000e34c <.LBB167>:
//            (Send a byte to the UART)             //
//--------------------------------------------------//
static int tty_putc (int txdata) {

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    e34c:	7c 40 81 00 	mov.b	#129,	r12	;#0x0081

0000e350 <.L29>:
    e350:	fc b2 00 00 	bit.b	#8,	0(r12)	;r2 As==11
    e354:	fd 23       	jnz	$-4      	;abs 0xe350

0000e356 <.Loc.20.1>:

  // Write the output character
  UART_TXD = txdata;
    e356:	c2 4d 84 00 	mov.b	r13,	&0x0084	;

0000e35a <.LBE157>:

void
cput_hex_long (long int n)
{
  cput_hex_byte (n >> 24);
  cput_hex_byte (n >> 16);
    e35a:	0c 49       	mov	r9,	r12	;
    e35c:	0d 48       	mov	r8,	r13	;
    e35e:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    e362:	b0 12 e2 e8 	call	#59618		;#0xe8e2
    e366:	07 4c       	mov	r12,	r7	;

0000e368 <.LBB169>:
}

void
cput_hex_byte (int n)
{
  cput_nibble (n >> 4);
    e368:	b0 12 8a e8 	call	#59530		;#0xe88a

0000e36c <.LBB171>:


void
cput_nibble (int n)
{
  tty_putc (hex[n&0x0f]);
    e36c:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    e370:	0c 5a       	add	r10,	r12	;
    e372:	6d 4c       	mov.b	@r12,	r13	;

0000e374 <.LBB173>:
//            (Send a byte to the UART)             //
//--------------------------------------------------//
static int tty_putc (int txdata) {

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    e374:	7c 40 81 00 	mov.b	#129,	r12	;#0x0081

0000e378 <.L30>:
    e378:	fc b2 00 00 	bit.b	#8,	0(r12)	;r2 As==11
    e37c:	fd 23       	jnz	$-4      	;abs 0xe378

0000e37e <.Loc.20.1>:

  // Write the output character
  UART_TXD = txdata;
    e37e:	c2 4d 84 00 	mov.b	r13,	&0x0084	;

0000e382 <.LBB175>:


void
cput_nibble (int n)
{
  tty_putc (hex[n&0x0f]);
    e382:	77 f0 0f 00 	and.b	#15,	r7	;#0x000f

0000e386 <.LVL46>:
    e386:	07 5a       	add	r10,	r7	;
    e388:	6d 47       	mov.b	@r7,	r13	;

0000e38a <.LBB177>:
//            (Send a byte to the UART)             //
//--------------------------------------------------//
static int tty_putc (int txdata) {

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    e38a:	7c 40 81 00 	mov.b	#129,	r12	;#0x0081

0000e38e <.L31>:
    e38e:	fc b2 00 00 	bit.b	#8,	0(r12)	;r2 As==11
    e392:	fd 23       	jnz	$-4      	;abs 0xe38e

0000e394 <.Loc.20.1>:

  // Write the output character
  UART_TXD = txdata;
    e394:	c2 4d 84 00 	mov.b	r13,	&0x0084	;

0000e398 <.LBE169>:
void
cput_hex_long (long int n)
{
  cput_hex_byte (n >> 24);
  cput_hex_byte (n >> 16);
  cput_hex_byte (n >> 8);
    e398:	0c 49       	mov	r9,	r12	;
    e39a:	0d 48       	mov	r8,	r13	;
    e39c:	b0 12 ba e8 	call	#59578		;#0xe8ba
    e3a0:	08 4c       	mov	r12,	r8	;

0000e3a2 <.LBB179>:
}

void
cput_hex_byte (int n)
{
  cput_nibble (n >> 4);
    e3a2:	b0 12 8a e8 	call	#59530		;#0xe88a

0000e3a6 <.LBB181>:


void
cput_nibble (int n)
{
  tty_putc (hex[n&0x0f]);
    e3a6:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    e3aa:	0c 5a       	add	r10,	r12	;
    e3ac:	6d 4c       	mov.b	@r12,	r13	;

0000e3ae <.LBB183>:
//            (Send a byte to the UART)             //
//--------------------------------------------------//
static int tty_putc (int txdata) {

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    e3ae:	7c 40 81 00 	mov.b	#129,	r12	;#0x0081

0000e3b2 <.L32>:
    e3b2:	fc b2 00 00 	bit.b	#8,	0(r12)	;r2 As==11
    e3b6:	fd 23       	jnz	$-4      	;abs 0xe3b2

0000e3b8 <.Loc.20.1>:

  // Write the output character
  UART_TXD = txdata;
    e3b8:	c2 4d 84 00 	mov.b	r13,	&0x0084	;

0000e3bc <.LBB185>:


void
cput_nibble (int n)
{
  tty_putc (hex[n&0x0f]);
    e3bc:	78 f0 0f 00 	and.b	#15,	r8	;#0x000f

0000e3c0 <.LVL54>:
    e3c0:	08 5a       	add	r10,	r8	;
    e3c2:	6d 48       	mov.b	@r8,	r13	;

0000e3c4 <.LBB187>:
//            (Send a byte to the UART)             //
//--------------------------------------------------//
static int tty_putc (int txdata) {

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    e3c4:	7c 40 81 00 	mov.b	#129,	r12	;#0x0081

0000e3c8 <.L33>:
    e3c8:	fc b2 00 00 	bit.b	#8,	0(r12)	;r2 As==11
    e3cc:	fd 23       	jnz	$-4      	;abs 0xe3c8

0000e3ce <.Loc.20.1>:

  // Write the output character
  UART_TXD = txdata;
    e3ce:	c2 4d 84 00 	mov.b	r13,	&0x0084	;

0000e3d2 <.LBB189>:
}

void
cput_hex_byte (int n)
{
  cput_nibble (n >> 4);
    e3d2:	0c 49       	mov	r9,	r12	;
    e3d4:	b0 12 8a e8 	call	#59530		;#0xe88a

0000e3d8 <.LBB191>:


void
cput_nibble (int n)
{
  tty_putc (hex[n&0x0f]);
    e3d8:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    e3dc:	0c 5a       	add	r10,	r12	;
    e3de:	6d 4c       	mov.b	@r12,	r13	;

0000e3e0 <.LBB193>:
//            (Send a byte to the UART)             //
//--------------------------------------------------//
static int tty_putc (int txdata) {

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    e3e0:	7c 40 81 00 	mov.b	#129,	r12	;#0x0081

0000e3e4 <.L34>:
    e3e4:	fc b2 00 00 	bit.b	#8,	0(r12)	;r2 As==11
    e3e8:	fd 23       	jnz	$-4      	;abs 0xe3e4

0000e3ea <.Loc.20.1>:

  // Write the output character
  UART_TXD = txdata;
    e3ea:	c2 4d 84 00 	mov.b	r13,	&0x0084	;

0000e3ee <.LBB195>:


void
cput_nibble (int n)
{
  tty_putc (hex[n&0x0f]);
    e3ee:	79 f0 0f 00 	and.b	#15,	r9	;#0x000f

0000e3f2 <.LVL60>:
    e3f2:	0a 59       	add	r9,	r10	;
    e3f4:	6d 4a       	mov.b	@r10,	r13	;

0000e3f6 <.LBB197>:
//            (Send a byte to the UART)             //
//--------------------------------------------------//
static int tty_putc (int txdata) {

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    e3f6:	7c 40 81 00 	mov.b	#129,	r12	;#0x0081

0000e3fa <.L35>:
    e3fa:	fc b2 00 00 	bit.b	#8,	0(r12)	;r2 As==11
    e3fe:	fd 23       	jnz	$-4      	;abs 0xe3fa

0000e400 <.Loc.20.1>:

  // Write the output character
  UART_TXD = txdata;
    e400:	c2 4d 84 00 	mov.b	r13,	&0x0084	;

0000e404 <.LBE189>:
{
  cput_hex_byte (n >> 24);
  cput_hex_byte (n >> 16);
  cput_hex_byte (n >> 8);
  cput_hex_byte (n);
}
    e404:	30 40 6a e8 	br	#0xe86a		;

0000e408 <cput_hex_block>:

void
cput_hex_block (char *block, int n)
{
    e408:	0a 12       	push	r10		;

0000e40a <.LCFI15>:
    e40a:	09 12       	push	r9		;

0000e40c <.LCFI16>:
    e40c:	08 12       	push	r8		;

0000e40e <.LCFI17>:
    e40e:	07 12       	push	r7		;

0000e410 <.LCFI18>:
    e410:	06 12       	push	r6		;

0000e412 <.LCFI19>:
    e412:	05 12       	push	r5		;

0000e414 <.LCFI20>:
    e414:	04 12       	push	r4		;

0000e416 <.LCFI21>:
  int i = 0;
  while (n)
    e416:	0d 93       	cmp	#0,	r13	;r3 As==00
    e418:	39 24       	jz	$+116    	;abs 0xe48c
    e41a:	3d 53       	add	#-1,	r13	;r3 As==11

0000e41c <.LVL65>:
    e41c:	07 4c       	mov	r12,	r7	;
    e41e:	07 5d       	add	r13,	r7	;
    e420:	05 4c       	mov	r12,	r5	;
    e422:	38 40 06 e0 	mov	#57350,	r8	;#0xe006

0000e426 <.LBB199>:
//            (Send a byte to the UART)             //
//--------------------------------------------------//
static int tty_putc (int txdata) {

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    e426:	7a 40 81 00 	mov.b	#129,	r10	;#0x0081

0000e42a <.Loc.20.1>:

  // Write the output character
  UART_TXD = txdata;
    e42a:	74 40 84 00 	mov.b	#132,	r4	;#0x0084

0000e42e <.LBE199>:
    {
      cput_hex_byte (*block++);
      if (--n == 0)
	break;
      i++;
      if ((i & 7) == 0)
    e42e:	16 43       	mov	#1,	r6	;r3 As==01
    e430:	06 8c       	sub	r12,	r6	;

0000e432 <.L51>:
cput_hex_block (char *block, int n)
{
  int i = 0;
  while (n)
    {
      cput_hex_byte (*block++);
    e432:	69 45       	mov.b	@r5,	r9	;

0000e434 <.LBB214>:
}

void
cput_hex_byte (int n)
{
  cput_nibble (n >> 4);
    e434:	0c 49       	mov	r9,	r12	;
    e436:	b0 12 8a e8 	call	#59530		;#0xe88a

0000e43a <.LBB208>:


void
cput_nibble (int n)
{
  tty_putc (hex[n&0x0f]);
    e43a:	0c 58       	add	r8,	r12	;
    e43c:	6c 4c       	mov.b	@r12,	r12	;

0000e43e <.L46>:
//            (Send a byte to the UART)             //
//--------------------------------------------------//
static int tty_putc (int txdata) {

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    e43e:	fa b2 00 00 	bit.b	#8,	0(r10)	;r2 As==11
    e442:	fd 23       	jnz	$-4      	;abs 0xe43e

0000e444 <.Loc.20.1>:

  // Write the output character
  UART_TXD = txdata;
    e444:	c4 4c 00 00 	mov.b	r12,	0(r4)	;

0000e448 <.LBB209>:


void
cput_nibble (int n)
{
  tty_putc (hex[n&0x0f]);
    e448:	79 f0 0f 00 	and.b	#15,	r9	;#0x000f

0000e44c <.LVL71>:
    e44c:	09 58       	add	r8,	r9	;
    e44e:	6c 49       	mov.b	@r9,	r12	;

0000e450 <.L47>:
//            (Send a byte to the UART)             //
//--------------------------------------------------//
static int tty_putc (int txdata) {

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    e450:	fa b2 00 00 	bit.b	#8,	0(r10)	;r2 As==11
    e454:	fd 23       	jnz	$-4      	;abs 0xe450

0000e456 <.Loc.20.1>:

  // Write the output character
  UART_TXD = txdata;
    e456:	c4 4c 00 00 	mov.b	r12,	0(r4)	;

0000e45a <.LBE209>:
{
  int i = 0;
  while (n)
    {
      cput_hex_byte (*block++);
      if (--n == 0)
    e45a:	05 97       	cmp	r7,	r5	;
    e45c:	17 24       	jz	$+48     	;abs 0xe48c

0000e45e <.LVL74>:
	break;
      i++;
      if ((i & 7) == 0)
    e45e:	0c 46       	mov	r6,	r12	;
    e460:	0c 55       	add	r5,	r12	;
    e462:	3c b0 07 00 	bit	#7,	r12	;
    e466:	09 20       	jnz	$+20     	;abs 0xe47a

0000e468 <.L49>:
//            (Send a byte to the UART)             //
//--------------------------------------------------//
static int tty_putc (int txdata) {

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    e468:	fa b2 00 00 	bit.b	#8,	0(r10)	;r2 As==11
    e46c:	fd 23       	jnz	$-4      	;abs 0xe468

0000e46e <.Loc.20.1>:

  // Write the output character
  UART_TXD = txdata;
    e46e:	f2 40 20 00 	mov.b	#32,	&0x0084	;#0x0020
    e472:	84 00 
    e474:	15 53       	inc	r5		;

0000e476 <.LVL75>:
    e476:	30 40 32 e4 	br	#0xe432		;

0000e47a <.L48>:
//            (Send a byte to the UART)             //
//--------------------------------------------------//
static int tty_putc (int txdata) {

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    e47a:	fa b2 00 00 	bit.b	#8,	0(r10)	;r2 As==11
    e47e:	fd 23       	jnz	$-4      	;abs 0xe47a

0000e480 <.Loc.20.1>:

  // Write the output character
  UART_TXD = txdata;
    e480:	f2 40 3a 00 	mov.b	#58,	&0x0084	;#0x003a
    e484:	84 00 
    e486:	15 53       	inc	r5		;

0000e488 <.LVL77>:
    e488:	30 40 32 e4 	br	#0xe432		;

0000e48c <.L44>:
      if ((i & 7) == 0)
	tty_putc (' ');
      else
	tty_putc (':');
    }
}
    e48c:	30 40 64 e8 	br	#0xe864		;

0000e490 <cput_nibble_block>:

void
cput_nibble_block (char *block, int n)
{
    e490:	0a 12       	push	r10		;

0000e492 <.LCFI22>:
    e492:	09 12       	push	r9		;

0000e494 <.LCFI23>:
  int i = 0;
  while (n)
    e494:	0d 93       	cmp	#0,	r13	;r3 As==00
    e496:	20 24       	jz	$+66     	;abs 0xe4d8
    e498:	3d 53       	add	#-1,	r13	;r3 As==11

0000e49a <.LVL81>:
}

void
cput_nibble_block (char *block, int n)
{
  int i = 0;
    e49a:	4b 43       	clr.b	r11		;
    e49c:	39 40 06 e0 	mov	#57350,	r9	;#0xe006

0000e4a0 <.LBB219>:
//            (Send a byte to the UART)             //
//--------------------------------------------------//
static int tty_putc (int txdata) {

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    e4a0:	7e 40 81 00 	mov.b	#129,	r14	;#0x0081

0000e4a4 <.Loc.20.1>:

  // Write the output character
  UART_TXD = txdata;
    e4a4:	7a 40 84 00 	mov.b	#132,	r10	;#0x0084

0000e4a8 <.L65>:


void
cput_nibble (int n)
{
  tty_putc (hex[n&0x0f]);
    e4a8:	6f 4c       	mov.b	@r12,	r15	;

0000e4aa <.LVL83>:
    e4aa:	7f f0 0f 00 	and.b	#15,	r15	;#0x000f

0000e4ae <.LVL84>:
    e4ae:	0f 59       	add	r9,	r15	;
    e4b0:	6f 4f       	mov.b	@r15,	r15	;

0000e4b2 <.L62>:
//            (Send a byte to the UART)             //
//--------------------------------------------------//
static int tty_putc (int txdata) {

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    e4b2:	fe b2 00 00 	bit.b	#8,	0(r14)	;r2 As==11
    e4b6:	fd 23       	jnz	$-4      	;abs 0xe4b2

0000e4b8 <.Loc.20.1>:

  // Write the output character
  UART_TXD = txdata;
    e4b8:	ca 4f 00 00 	mov.b	r15,	0(r10)	;

0000e4bc <.LBE219>:
{
  int i = 0;
  while (n)
    {
      cput_nibble (*block);
      if (--n == 0)
    e4bc:	0b 9d       	cmp	r13,	r11	;
    e4be:	0c 24       	jz	$+26     	;abs 0xe4d8

0000e4c0 <.Loc.89.1>:
	break;
      i++;
    e4c0:	1b 53       	inc	r11		;

0000e4c2 <.LVL87>:
      if ((i & 7) == 0)
    e4c2:	3b b0 07 00 	bit	#7,	r11	;
    e4c6:	f0 23       	jnz	$-30     	;abs 0xe4a8

0000e4c8 <.L64>:
//            (Send a byte to the UART)             //
//--------------------------------------------------//
static int tty_putc (int txdata) {

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    e4c8:	fe b2 00 00 	bit.b	#8,	0(r14)	;r2 As==11
    e4cc:	fd 23       	jnz	$-4      	;abs 0xe4c8

0000e4ce <.Loc.20.1>:

  // Write the output character
  UART_TXD = txdata;
    e4ce:	f2 40 20 00 	mov.b	#32,	&0x0084	;#0x0020
    e4d2:	84 00 
    e4d4:	30 40 a8 e4 	br	#0xe4a8		;

0000e4d8 <.L60>:
	break;
      i++;
      if ((i & 7) == 0)
	tty_putc (' ');
    }
}
    e4d8:	30 40 6e e8 	br	#0xe86e		;

0000e4dc <cput_number>:

void
cput_number (int n)
{
    e4dc:	0a 12       	push	r10		;

0000e4de <.LCFI24>:
    e4de:	09 12       	push	r9		;

0000e4e0 <.LCFI25>:
    e4e0:	08 12       	push	r8		;

0000e4e2 <.LCFI26>:
    e4e2:	07 12       	push	r7		;

0000e4e4 <.LCFI27>:
    e4e4:	06 12       	push	r6		;

0000e4e6 <.LCFI28>:
    e4e6:	05 12       	push	r5		;

0000e4e8 <.LCFI29>:
    e4e8:	04 12       	push	r4		;

0000e4ea <.LCFI30>:
    e4ea:	31 80 16 00 	sub	#22,	r1	;#0x0016

0000e4ee <.LCFI31>:
    e4ee:	0a 4c       	mov	r12,	r10	;

0000e4f0 <.LVL90>:
  char buf[20];
  int i = 0;
  if (n < 0)
    e4f0:	0c 93       	cmp	#0,	r12	;r3 As==00
    e4f2:	40 38       	jl	$+130    	;abs 0xe574

0000e4f4 <.Loc.105.1>:
    {
      tty_putc ('-');
      n = -n;
    }
  while (n > 9)
    e4f4:	7c 40 09 00 	mov.b	#9,	r12	;

0000e4f8 <.LVL91>:
    e4f8:	0c 9a       	cmp	r10,	r12	;
    e4fa:	4b 34       	jge	$+152    	;abs 0xe592

0000e4fc <.L84>:
    e4fc:	0c 41       	mov	r1,	r12	;
    e4fe:	2c 53       	incd	r12		;
    e500:	81 4c 00 00 	mov	r12,	0(r1)	;
    e504:	09 4c       	mov	r12,	r9	;
    e506:	5c 43       	mov.b	#1,	r12	;r3 As==01
    e508:	0c 89       	sub	r9,	r12	;
    e50a:	04 4c       	mov	r12,	r4	;
    e50c:	35 40 22 e8 	mov	#59426,	r5	;#0xe822
    e510:	36 40 d6 e7 	mov	#59350,	r6	;#0xe7d6

0000e514 <.Loc.107.1>:
    {
      buf[i++] = (n%10) + '0';
    e514:	78 40 0a 00 	mov.b	#10,	r8	;#0x000a

0000e518 <.L75>:
    e518:	07 44       	mov	r4,	r7	;
    e51a:	07 59       	add	r9,	r7	;

0000e51c <.LVL93>:
    e51c:	0d 48       	mov	r8,	r13	;
    e51e:	0c 4a       	mov	r10,	r12	;
    e520:	85 12       	call	r5		;
    e522:	7c 50 30 00 	add.b	#48,	r12	;#0x0030
    e526:	c9 4c 00 00 	mov.b	r12,	0(r9)	;

0000e52a <.Loc.108.1>:
      n /= 10;
    e52a:	0d 48       	mov	r8,	r13	;
    e52c:	0c 4a       	mov	r10,	r12	;
    e52e:	86 12       	call	r6		;
    e530:	0a 4c       	mov	r12,	r10	;
    e532:	19 53       	inc	r9		;

0000e534 <.Loc.105.1>:
  if (n < 0)
    {
      tty_putc ('-');
      n = -n;
    }
  while (n > 9)
    e534:	7c 40 09 00 	mov.b	#9,	r12	;
    e538:	0c 9a       	cmp	r10,	r12	;
    e53a:	ee 3b       	jl	$-34     	;abs 0xe518
    e53c:	0d 47       	mov	r7,	r13	;
    e53e:	1d 53       	inc	r13		;

0000e540 <.L74>:
    {
      buf[i++] = (n%10) + '0';
      n /= 10;
    }
  buf[i++] = (n%10) + '0';
    e540:	27 51       	add	@r1,	r7	;

0000e542 <.LVL98>:
    e542:	7a 50 30 00 	add.b	#48,	r10	;#0x0030

0000e546 <.LVL99>:
    e546:	c7 4a 00 00 	mov.b	r10,	0(r7)	;
    e54a:	3d 53       	add	#-1,	r13	;r3 As==11
    e54c:	2d 51       	add	@r1,	r13	;
    e54e:	0a 41       	mov	r1,	r10	;
    e550:	1a 53       	inc	r10		;

0000e552 <.LBB227>:
//            (Send a byte to the UART)             //
//--------------------------------------------------//
static int tty_putc (int txdata) {

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    e552:	7c 40 81 00 	mov.b	#129,	r12	;#0x0081

0000e556 <.Loc.20.1>:

  // Write the output character
  UART_TXD = txdata;
    e556:	7f 40 84 00 	mov.b	#132,	r15	;#0x0084

0000e55a <.L77>:
      buf[i++] = (n%10) + '0';
      n /= 10;
    }
  buf[i++] = (n%10) + '0';
  while (i > 0)
    tty_putc (buf[--i]);
    e55a:	6e 4d       	mov.b	@r13,	r14	;

0000e55c <.L76>:
//            (Send a byte to the UART)             //
//--------------------------------------------------//
static int tty_putc (int txdata) {

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    e55c:	fc b2 00 00 	bit.b	#8,	0(r12)	;r2 As==11
    e560:	fd 23       	jnz	$-4      	;abs 0xe55c

0000e562 <.Loc.20.1>:

  // Write the output character
  UART_TXD = txdata;
    e562:	cf 4e 00 00 	mov.b	r14,	0(r15)	;
    e566:	3d 53       	add	#-1,	r13	;r3 As==11

0000e568 <.LBE230>:
    {
      buf[i++] = (n%10) + '0';
      n /= 10;
    }
  buf[i++] = (n%10) + '0';
  while (i > 0)
    e568:	0a 9d       	cmp	r13,	r10	;
    e56a:	f7 23       	jnz	$-16     	;abs 0xe55a

0000e56c <.Loc.113.1>:
    tty_putc (buf[--i]);
}
    e56c:	31 50 16 00 	add	#22,	r1	;#0x0016
    e570:	30 40 64 e8 	br	#0xe864		;

0000e574 <.L83>:
//            (Send a byte to the UART)             //
//--------------------------------------------------//
static int tty_putc (int txdata) {

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    e574:	7c 40 81 00 	mov.b	#129,	r12	;#0x0081

0000e578 <.L73>:
    e578:	fc b2 00 00 	bit.b	#8,	0(r12)	;r2 As==11
    e57c:	fd 23       	jnz	$-4      	;abs 0xe578

0000e57e <.Loc.20.1>:

  // Write the output character
  UART_TXD = txdata;
    e57e:	f2 40 2d 00 	mov.b	#45,	&0x0084	;#0x002d
    e582:	84 00 

0000e584 <.LBE231>:
  char buf[20];
  int i = 0;
  if (n < 0)
    {
      tty_putc ('-');
      n = -n;
    e584:	4c 43       	clr.b	r12		;
    e586:	0c 8a       	sub	r10,	r12	;
    e588:	0a 4c       	mov	r12,	r10	;

0000e58a <.Loc.105.1>:
    }
  while (n > 9)
    e58a:	7c 40 09 00 	mov.b	#9,	r12	;
    e58e:	0c 9a       	cmp	r10,	r12	;
    e590:	b5 3b       	jl	$-148    	;abs 0xe4fc

0000e592 <.L78>:
    e592:	5d 43       	mov.b	#1,	r13	;r3 As==01
    e594:	47 43       	clr.b	r7		;
    e596:	0c 41       	mov	r1,	r12	;
    e598:	2c 53       	incd	r12		;
    e59a:	81 4c 00 00 	mov	r12,	0(r1)	;
    e59e:	30 40 40 e5 	br	#0xe540		;

0000e5a2 <cprintf>:
    tty_putc (buf[--i]);
}

void
cprintf (const char *fmt, ...)
{
    e5a2:	0a 12       	push	r10		;

0000e5a4 <.LCFI32>:
    e5a4:	09 12       	push	r9		;

0000e5a6 <.LCFI33>:
    e5a6:	08 12       	push	r8		;

0000e5a8 <.LCFI34>:
    e5a8:	07 12       	push	r7		;

0000e5aa <.LCFI35>:
    e5aa:	06 12       	push	r6		;

0000e5ac <.LCFI36>:
    e5ac:	05 12       	push	r5		;

0000e5ae <.LCFI37>:
    e5ae:	04 12       	push	r4		;

0000e5b0 <.LCFI38>:
    e5b0:	19 41 10 00 	mov	16(r1),	r9	;0x00010

0000e5b4 <.Loc.122.1>:
  va_list v;
  int i;
  char *s;

  va_start (v, fmt);
    e5b4:	08 41       	mov	r1,	r8	;
    e5b6:	38 50 12 00 	add	#18,	r8	;#0x0012

0000e5ba <.LVL106>:

  while (*fmt)
    e5ba:	6c 49       	mov.b	@r9,	r12	;
    e5bc:	0c 93       	cmp	#0,	r12	;r3 As==00
    e5be:	2c 24       	jz	$+90     	;abs 0xe618

0000e5c0 <.LBB233>:
//            (Send a byte to the UART)             //
//--------------------------------------------------//
static int tty_putc (int txdata) {

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    e5c0:	7a 40 81 00 	mov.b	#129,	r10	;#0x0081

0000e5c4 <.L110>:
    e5c4:	04 49       	mov	r9,	r4	;
    e5c6:	14 53       	inc	r4		;

0000e5c8 <.LBE233>:

  va_start (v, fmt);

  while (*fmt)
    {
      if (*fmt != '%')
    e5c8:	3c 90 25 00 	cmp	#37,	r12	;#0x0025
    e5cc:	29 20       	jnz	$+84     	;abs 0xe620

0000e5ce <.LVL108>:
	tty_putc (*fmt);
      else
	switch (*++fmt)
    e5ce:	5d 49 01 00 	mov.b	1(r9),	r13	;
    e5d2:	29 53       	incd	r9		;
    e5d4:	7d 90 64 00 	cmp.b	#100,	r13	;#0x0064
    e5d8:	d4 24       	jz	$+426    	;abs 0xe782
    e5da:	7e 40 64 00 	mov.b	#100,	r14	;#0x0064
    e5de:	4e 9d       	cmp.b	r13,	r14	;
    e5e0:	2f 2c       	jc	$+96     	;abs 0xe640
    e5e2:	7d 90 73 00 	cmp.b	#115,	r13	;#0x0073
    e5e6:	c2 24       	jz	$+390    	;abs 0xe76c
    e5e8:	7e 40 73 00 	mov.b	#115,	r14	;#0x0073
    e5ec:	4e 9d       	cmp.b	r13,	r14	;
    e5ee:	42 28       	jnc	$+134    	;abs 0xe674
    e5f0:	7d 90 6c 00 	cmp.b	#108,	r13	;#0x006c
    e5f4:	51 24       	jz	$+164    	;abs 0xe698
    e5f6:	7d 90 6e 00 	cmp.b	#110,	r13	;#0x006e
    e5fa:	1a 20       	jnz	$+54     	;abs 0xe630

0000e5fc <.Loc.164.1>:
	    s = va_arg (v, char *);
	    i = va_arg (v, int);
	    cput_hex_block (s, i);
	    break;
	  case 'n':
	    s = va_arg (v, char *);
    e5fc:	2c 48       	mov	@r8,	r12	;

0000e5fe <.Loc.165.1>:
	    i = va_arg (v, int);
    e5fe:	38 50 03 00 	add	#3,	r8	;

0000e602 <.LVL109>:
    e602:	0d 48       	mov	r8,	r13	;
    e604:	1d c3       	bic	#1,	r13	;r3 As==01
    e606:	08 4d       	mov	r13,	r8	;

0000e608 <.LVL110>:
    e608:	28 53       	incd	r8		;

0000e60a <.LVL111>:
	    cput_nibble_block (s, i);
    e60a:	2d 4d       	mov	@r13,	r13	;
    e60c:	b0 12 90 e4 	call	#58512		;#0xe490

0000e610 <.LVL112>:
  int i;
  char *s;

  va_start (v, fmt);

  while (*fmt)
    e610:	5c 44 01 00 	mov.b	1(r4),	r12	;
    e614:	0c 93       	cmp	#0,	r12	;r3 As==00
    e616:	d6 23       	jnz	$-82     	;abs 0xe5c4

0000e618 <.L85>:
	    tty_putc (s[0]);
	    break;
	  }
      fmt ++;
    }
}
    e618:	30 40 64 e8 	br	#0xe864		;
    e61c:	30 40 96 e7 	br	#0xe796		;

0000e620 <.L88>:
//            (Send a byte to the UART)             //
//--------------------------------------------------//
static int tty_putc (int txdata) {

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    e620:	fa b2 00 00 	bit.b	#8,	0(r10)	;r2 As==11
    e624:	fd 23       	jnz	$-4      	;abs 0xe620

0000e626 <.Loc.20.1>:

  // Write the output character
  UART_TXD = txdata;
    e626:	c2 4c 84 00 	mov.b	r12,	&0x0084	;
    e62a:	0c 44       	mov	r4,	r12	;
    e62c:	04 49       	mov	r9,	r4	;
    e62e:	09 4c       	mov	r12,	r9	;

0000e630 <.L89>:
  int i;
  char *s;

  va_start (v, fmt);

  while (*fmt)
    e630:	5c 44 01 00 	mov.b	1(r4),	r12	;
    e634:	0c 93       	cmp	#0,	r12	;r3 As==00
    e636:	c6 23       	jnz	$-114    	;abs 0xe5c4

0000e638 <.Loc.175.1>:
	    tty_putc (s[0]);
	    break;
	  }
      fmt ++;
    }
}
    e638:	30 40 64 e8 	br	#0xe864		;
    e63c:	30 40 96 e7 	br	#0xe796		;

0000e640 <.L130>:
  while (*fmt)
    {
      if (*fmt != '%')
	tty_putc (*fmt);
      else
	switch (*++fmt)
    e640:	7d 90 42 00 	cmp.b	#66,	r13	;#0x0042
    e644:	6c 24       	jz	$+218    	;abs 0xe71e
    e646:	7e 40 42 00 	mov.b	#66,	r14	;#0x0042
    e64a:	4e 9d       	cmp.b	r13,	r14	;
    e64c:	5d 2c       	jc	$+188    	;abs 0xe708
    e64e:	7d 90 62 00 	cmp.b	#98,	r13	;#0x0062
    e652:	3a 24       	jz	$+118    	;abs 0xe6c8
    e654:	7d 90 63 00 	cmp.b	#99,	r13	;#0x0063
    e658:	eb 23       	jnz	$-40     	;abs 0xe630

0000e65a <.Loc.135.1>:
	  {
	  case '%':
	    tty_putc ('%');
	    break;
	  case 'c':
	    i = va_arg (v, int);
    e65a:	18 53       	inc	r8		;

0000e65c <.LVL117>:
    e65c:	0c 48       	mov	r8,	r12	;
    e65e:	1c c3       	bic	#1,	r12	;r3 As==01
    e660:	08 4c       	mov	r12,	r8	;

0000e662 <.LVL118>:
    e662:	28 53       	incd	r8		;

0000e664 <.LVL119>:
    e664:	2c 4c       	mov	@r12,	r12	;

0000e666 <.L103>:
//            (Send a byte to the UART)             //
//--------------------------------------------------//
static int tty_putc (int txdata) {

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    e666:	fa b2 00 00 	bit.b	#8,	0(r10)	;r2 As==11
    e66a:	fd 23       	jnz	$-4      	;abs 0xe666

0000e66c <.L126>:

  // Write the output character
  UART_TXD = txdata;
    e66c:	c2 4c 84 00 	mov.b	r12,	&0x0084	;
    e670:	30 40 30 e6 	br	#0xe630		;

0000e674 <.L98>:
  while (*fmt)
    {
      if (*fmt != '%')
	tty_putc (*fmt);
      else
	switch (*++fmt)
    e674:	7d 90 77 00 	cmp.b	#119,	r13	;#0x0077
    e678:	1d 24       	jz	$+60     	;abs 0xe6b4
    e67a:	7d 90 78 00 	cmp.b	#120,	r13	;#0x0078
    e67e:	d8 23       	jnz	$-78     	;abs 0xe630

0000e680 <.Loc.159.1>:
	  case 'l':
	    i = va_arg (v, int);
	    cput_hex_long (i);
	    break;
	  case 'x':
	    s = va_arg (v, char *);
    e680:	2c 48       	mov	@r8,	r12	;

0000e682 <.Loc.160.1>:
	    i = va_arg (v, int);
    e682:	38 50 03 00 	add	#3,	r8	;

0000e686 <.LVL122>:
    e686:	0d 48       	mov	r8,	r13	;
    e688:	1d c3       	bic	#1,	r13	;r3 As==01
    e68a:	08 4d       	mov	r13,	r8	;

0000e68c <.LVL123>:
    e68c:	28 53       	incd	r8		;

0000e68e <.LVL124>:
	    cput_hex_block (s, i);
    e68e:	2d 4d       	mov	@r13,	r13	;
    e690:	b0 12 08 e4 	call	#58376		;#0xe408

0000e694 <.LVL125>:
	    break;
    e694:	30 40 30 e6 	br	#0xe630		;

0000e698 <.L99>:
	  case 'w':
	    i = va_arg (v, int);
	    cput_hex_word (i);
	    break;
	  case 'l':
	    i = va_arg (v, int);
    e698:	18 53       	inc	r8		;

0000e69a <.LVL126>:
    e69a:	0c 48       	mov	r8,	r12	;
    e69c:	1c c3       	bic	#1,	r12	;r3 As==01
    e69e:	08 4c       	mov	r12,	r8	;

0000e6a0 <.LVL127>:
    e6a0:	28 53       	incd	r8		;

0000e6a2 <.LVL128>:
	    cput_hex_long (i);
    e6a2:	2c 4c       	mov	@r12,	r12	;
    e6a4:	3c b0 00 80 	bit	#32768,	r12	;#0x8000
    e6a8:	0d 7d       	subc	r13,	r13	;
    e6aa:	3d e3       	inv	r13		;
    e6ac:	b0 12 10 e3 	call	#58128		;#0xe310

0000e6b0 <.LVL129>:
	    break;
    e6b0:	30 40 30 e6 	br	#0xe630		;

0000e6b4 <.L101>:
	  case 'B':
	    i = va_arg (v, int);
	    cput_binary_byte (i);
	    break;
	  case 'w':
	    i = va_arg (v, int);
    e6b4:	18 53       	inc	r8		;

0000e6b6 <.LVL130>:
    e6b6:	0c 48       	mov	r8,	r12	;
    e6b8:	1c c3       	bic	#1,	r12	;r3 As==01
    e6ba:	08 4c       	mov	r12,	r8	;

0000e6bc <.LVL131>:
    e6bc:	28 53       	incd	r8		;

0000e6be <.LVL132>:
	    cput_hex_word (i);
    e6be:	2c 4c       	mov	@r12,	r12	;
    e6c0:	b0 12 9a e2 	call	#58010		;#0xe29a

0000e6c4 <.LVL133>:
	    break;
    e6c4:	30 40 30 e6 	br	#0xe630		;

0000e6c8 <.L95>:
	  case 'd':
	    i = va_arg (v, int);
	    cput_number(i);
	    break;
	  case 'b':
	    i = va_arg (v, int);
    e6c8:	18 53       	inc	r8		;

0000e6ca <.LVL134>:
    e6ca:	0c 48       	mov	r8,	r12	;
    e6cc:	1c c3       	bic	#1,	r12	;r3 As==01
    e6ce:	08 4c       	mov	r12,	r8	;

0000e6d0 <.LVL135>:
    e6d0:	28 53       	incd	r8		;

0000e6d2 <.LVL136>:
    e6d2:	26 4c       	mov	@r12,	r6	;

0000e6d4 <.LBB242>:


void
cput_nibble (int n)
{
  tty_putc (hex[n&0x0f]);
    e6d4:	37 40 06 e0 	mov	#57350,	r7	;#0xe006

0000e6d8 <.LBE244>:
}

void
cput_hex_byte (int n)
{
  cput_nibble (n >> 4);
    e6d8:	0c 46       	mov	r6,	r12	;
    e6da:	b0 12 8a e8 	call	#59530		;#0xe88a

0000e6de <.LBB249>:


void
cput_nibble (int n)
{
  tty_putc (hex[n&0x0f]);
    e6de:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    e6e2:	0c 57       	add	r7,	r12	;
    e6e4:	6c 4c       	mov.b	@r12,	r12	;

0000e6e6 <.L104>:
//            (Send a byte to the UART)             //
//--------------------------------------------------//
static int tty_putc (int txdata) {

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    e6e6:	fa b2 00 00 	bit.b	#8,	0(r10)	;r2 As==11
    e6ea:	fd 23       	jnz	$-4      	;abs 0xe6e6

0000e6ec <.Loc.20.1>:

  // Write the output character
  UART_TXD = txdata;
    e6ec:	c2 4c 84 00 	mov.b	r12,	&0x0084	;

0000e6f0 <.LBB250>:


void
cput_nibble (int n)
{
  tty_putc (hex[n&0x0f]);
    e6f0:	76 f0 0f 00 	and.b	#15,	r6	;#0x000f
    e6f4:	07 56       	add	r6,	r7	;
    e6f6:	6c 47       	mov.b	@r7,	r12	;

0000e6f8 <.L105>:
//            (Send a byte to the UART)             //
//--------------------------------------------------//
static int tty_putc (int txdata) {

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    e6f8:	fa b2 00 00 	bit.b	#8,	0(r10)	;r2 As==11
    e6fc:	b7 27       	jz	$-144    	;abs 0xe66c
    e6fe:	fa b2 00 00 	bit.b	#8,	0(r10)	;r2 As==11
    e702:	fa 23       	jnz	$-10     	;abs 0xe6f8
    e704:	30 40 6c e6 	br	#0xe66c		;

0000e708 <.L132>:
  while (*fmt)
    {
      if (*fmt != '%')
	tty_putc (*fmt);
      else
	switch (*++fmt)
    e708:	7d 90 25 00 	cmp.b	#37,	r13	;#0x0025
    e70c:	91 23       	jnz	$-220    	;abs 0xe630

0000e70e <.L94>:
//            (Send a byte to the UART)             //
//--------------------------------------------------//
static int tty_putc (int txdata) {

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    e70e:	fa b2 00 00 	bit.b	#8,	0(r10)	;r2 As==11
    e712:	fd 23       	jnz	$-4      	;abs 0xe70e

0000e714 <.Loc.20.1>:

  // Write the output character
  UART_TXD = txdata;
    e714:	f2 40 25 00 	mov.b	#37,	&0x0084	;#0x0025
    e718:	84 00 
    e71a:	30 40 30 e6 	br	#0xe630		;

0000e71e <.L92>:
	  case 'b':
	    i = va_arg (v, int);
	    cput_hex_byte (i);
	    break;
	  case 'B':
	    i = va_arg (v, int);
    e71e:	18 53       	inc	r8		;

0000e720 <.LVL143>:
    e720:	0c 48       	mov	r8,	r12	;
    e722:	1c c3       	bic	#1,	r12	;r3 As==01
    e724:	08 4c       	mov	r12,	r8	;

0000e726 <.LVL144>:
    e726:	28 53       	incd	r8		;

0000e728 <.LVL145>:
    e728:	26 4c       	mov	@r12,	r6	;

0000e72a <.LBB256>:

void
cput_binary_byte (int n)
{
  int i;
  for (i=7; i>=0; i--)
    e72a:	75 40 07 00 	mov.b	#7,	r5	;

0000e72e <.LBB258>:

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);

  // Write the output character
  UART_TXD = txdata;
    e72e:	77 40 84 00 	mov.b	#132,	r7	;#0x0084

0000e732 <.LBE258>:
void
cput_binary_byte (int n)
{
  int i;
  for (i=7; i>=0; i--)
    tty_putc((n & (1<<i)) ? '1' : '0');
    e732:	0c 46       	mov	r6,	r12	;
    e734:	0d 45       	mov	r5,	r13	;
    e736:	b0 12 98 e8 	call	#59544		;#0xe898
    e73a:	1c b3       	bit	#1,	r12	;r3 As==01
    e73c:	10 24       	jz	$+34     	;abs 0xe75e

0000e73e <.L133>:
    e73e:	7c 40 31 00 	mov.b	#49,	r12	;#0x0031

0000e742 <.L107>:
//            (Send a byte to the UART)             //
//--------------------------------------------------//
static int tty_putc (int txdata) {

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    e742:	fa b2 00 00 	bit.b	#8,	0(r10)	;r2 As==11
    e746:	fd 23       	jnz	$-4      	;abs 0xe742

0000e748 <.L134>:

  // Write the output character
  UART_TXD = txdata;
    e748:	c7 4c 00 00 	mov.b	r12,	0(r7)	;

0000e74c <.LBE262>:

void
cput_binary_byte (int n)
{
  int i;
  for (i=7; i>=0; i--)
    e74c:	35 53       	add	#-1,	r5	;r3 As==11
    e74e:	35 93       	cmp	#-1,	r5	;r3 As==11
    e750:	6f 27       	jz	$-288    	;abs 0xe630

0000e752 <.Loc.44.1>:
    tty_putc((n & (1<<i)) ? '1' : '0');
    e752:	0c 46       	mov	r6,	r12	;
    e754:	0d 45       	mov	r5,	r13	;
    e756:	b0 12 98 e8 	call	#59544		;#0xe898
    e75a:	1c b3       	bit	#1,	r12	;r3 As==01
    e75c:	f0 23       	jnz	$-30     	;abs 0xe73e

0000e75e <.L111>:
    e75e:	7c 40 30 00 	mov.b	#48,	r12	;#0x0030

0000e762 <.LBB263>:
//            (Send a byte to the UART)             //
//--------------------------------------------------//
static int tty_putc (int txdata) {

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    e762:	fa b2 00 00 	bit.b	#8,	0(r10)	;r2 As==11
    e766:	ed 23       	jnz	$-36     	;abs 0xe742
    e768:	30 40 48 e7 	br	#0xe748		;

0000e76c <.L97>:
	    i = va_arg (v, int);
	    cput_nibble_block (s, i);
	    break;
	  case 's':
	    s = va_arg (v, char *);
	    tty_putc (s[0]);
    e76c:	2c 48       	mov	@r8,	r12	;
    e76e:	28 53       	incd	r8		;

0000e770 <.LVL152>:
    e770:	6c 4c       	mov.b	@r12,	r12	;

0000e772 <.L109>:
//            (Send a byte to the UART)             //
//--------------------------------------------------//
static int tty_putc (int txdata) {

  // Wait until the TX buffer is not full
  while (UART_STAT & UART_TX_FULL);
    e772:	fa b2 00 00 	bit.b	#8,	0(r10)	;r2 As==11
    e776:	7a 27       	jz	$-266    	;abs 0xe66c
    e778:	fa b2 00 00 	bit.b	#8,	0(r10)	;r2 As==11
    e77c:	fa 23       	jnz	$-10     	;abs 0xe772
    e77e:	30 40 6c e6 	br	#0xe66c		;

0000e782 <.L90>:
	  case 'c':
	    i = va_arg (v, int);
	    tty_putc(i);
	    break;
	  case 'd':
	    i = va_arg (v, int);
    e782:	18 53       	inc	r8		;

0000e784 <.LVL155>:
    e784:	0c 48       	mov	r8,	r12	;
    e786:	1c c3       	bic	#1,	r12	;r3 As==01
    e788:	08 4c       	mov	r12,	r8	;

0000e78a <.LVL156>:
    e78a:	28 53       	incd	r8		;

0000e78c <.LVL157>:
	    cput_number(i);
    e78c:	2c 4c       	mov	@r12,	r12	;
    e78e:	b0 12 dc e4 	call	#58588		;#0xe4dc

0000e792 <.LVL158>:
	    break;
    e792:	30 40 30 e6 	br	#0xe630		;

0000e796 <udivmodhi4>:
    e796:	7f 40 11 00 	mov.b	#17,	r15	;#0x0011

0000e79a <.Loc.35.1>:
    e79a:	5b 43       	mov.b	#1,	r11	;r3 As==01

0000e79c <.L2>:
    e79c:	0d 9c       	cmp	r12,	r13	;
    e79e:	08 28       	jnc	$+18     	;abs 0xe7b0

0000e7a0 <.L15>:
    e7a0:	4f 43       	clr.b	r15		;

0000e7a2 <.L4>:
    e7a2:	0b 93       	cmp	#0,	r11	;r3 As==00
    e7a4:	0e 20       	jnz	$+30     	;abs 0xe7c2

0000e7a6 <.L5>:
    e7a6:	0e 93       	cmp	#0,	r14	;r3 As==00
    e7a8:	01 24       	jz	$+4      	;abs 0xe7ac
    e7aa:	0f 4c       	mov	r12,	r15	;

0000e7ac <.L1>:
    e7ac:	0c 4f       	mov	r15,	r12	;
    e7ae:	30 41       	ret			

0000e7b0 <.L3>:
    e7b0:	3f 53       	add	#-1,	r15	;r3 As==11

0000e7b2 <.Loc.38.1>:
    e7b2:	0f 93       	cmp	#0,	r15	;r3 As==00
    e7b4:	f8 27       	jz	$-14     	;abs 0xe7a6

0000e7b6 <.Loc.38.1>:
    e7b6:	0d 93       	cmp	#0,	r13	;r3 As==00
    e7b8:	f3 3b       	jl	$-24     	;abs 0xe7a0

0000e7ba <.Loc.40.1>:
    e7ba:	0d 5d       	rla	r13		;

0000e7bc <.Loc.41.1>:
    e7bc:	0b 5b       	rla	r11		;
    e7be:	30 40 9c e7 	br	#0xe79c		;

0000e7c2 <.L9>:
    e7c2:	0c 9d       	cmp	r13,	r12	;
    e7c4:	02 28       	jnc	$+6      	;abs 0xe7ca

0000e7c6 <.Loc.47.1>:
    e7c6:	0c 8d       	sub	r13,	r12	;

0000e7c8 <.Loc.48.1>:
    e7c8:	0f db       	bis	r11,	r15	;

0000e7ca <.L8>:
    e7ca:	12 c3       	clrc			
    e7cc:	0b 10       	rrc	r11		;

0000e7ce <.Loc.51.1>:
    e7ce:	12 c3       	clrc			
    e7d0:	0d 10       	rrc	r13		;
    e7d2:	30 40 a2 e7 	br	#0xe7a2		;

0000e7d6 <__mspabi_divi>:
    e7d6:	0a 12       	push	r10		;

0000e7d8 <.LCFI0>:
    e7d8:	0f 4c       	mov	r12,	r15	;
    e7da:	0e 4d       	mov	r13,	r14	;

0000e7dc <.LVL14>:
    e7dc:	3b 40 96 e7 	mov	#59286,	r11	;#0xe796

0000e7e0 <.Loc.64.1>:
    e7e0:	0c 93       	cmp	#0,	r12	;r3 As==00
    e7e2:	1a 34       	jge	$+54     	;abs 0xe818

0000e7e4 <.Loc.66.1>:
    e7e4:	4c 43       	clr.b	r12		;

0000e7e6 <.LVL15>:
    e7e6:	0c 8f       	sub	r15,	r12	;
    e7e8:	0f 4c       	mov	r12,	r15	;

0000e7ea <.LVL16>:
    e7ea:	0d 93       	cmp	#0,	r13	;r3 As==00
    e7ec:	0d 34       	jge	$+28     	;abs 0xe808

0000e7ee <.Loc.67.1>:
    e7ee:	5a 43       	mov.b	#1,	r10	;r3 As==01

0000e7f0 <.L21>:
    e7f0:	0d 43       	clr	r13		;
    e7f2:	0d 8e       	sub	r14,	r13	;

0000e7f4 <.LVL18>:
    e7f4:	4e 43       	clr.b	r14		;

0000e7f6 <.LVL19>:
    e7f6:	0c 4f       	mov	r15,	r12	;

0000e7f8 <.LVL20>:
    e7f8:	8b 12       	call	r11		;

0000e7fa <.LVL21>:
    e7fa:	1a 93       	cmp	#1,	r10	;r3 As==01
    e7fc:	03 24       	jz	$+8      	;abs 0xe804

0000e7fe <.L20>:
    e7fe:	4d 43       	clr.b	r13		;
    e800:	0d 8c       	sub	r12,	r13	;
    e802:	0c 4d       	mov	r13,	r12	;

0000e804 <.L16>:
    e804:	3a 41       	pop	r10		;
    e806:	30 41       	ret			

0000e808 <.L18>:
    e808:	4e 43       	clr.b	r14		;
    e80a:	8b 12       	call	r11		;

0000e80c <.LVL25>:
    e80c:	30 40 fe e7 	br	#0xe7fe		;

0000e810 <.L27>:
    e810:	4e 43       	clr.b	r14		;
    e812:	8b 12       	call	r11		;

0000e814 <.LVL27>:
    e814:	30 40 04 e8 	br	#0xe804		;

0000e818 <.L17>:
    e818:	0d 93       	cmp	#0,	r13	;r3 As==00
    e81a:	fa 37       	jge	$-10     	;abs 0xe810

0000e81c <.Loc.61.1>:
    e81c:	4a 43       	clr.b	r10		;
    e81e:	30 40 f0 e7 	br	#0xe7f0		;

0000e822 <__mspabi_remi>:
    e822:	0a 12       	push	r10		;

0000e824 <.LCFI1>:
    e824:	0c 93       	cmp	#0,	r12	;r3 As==00
    e826:	13 34       	jge	$+40     	;abs 0xe84e

0000e828 <.Loc.92.1>:
    e828:	4e 43       	clr.b	r14		;
    e82a:	0e 8c       	sub	r12,	r14	;
    e82c:	0c 4e       	mov	r14,	r12	;

0000e82e <.LVL31>:
    e82e:	5a 43       	mov.b	#1,	r10	;r3 As==01

0000e830 <.L29>:
    e830:	0d 93       	cmp	#0,	r13	;r3 As==00
    e832:	03 34       	jge	$+8      	;abs 0xe83a
    e834:	4e 43       	clr.b	r14		;
    e836:	0e 8d       	sub	r13,	r14	;
    e838:	0d 4e       	mov	r14,	r13	;

0000e83a <.L30>:
    e83a:	5e 43       	mov.b	#1,	r14	;r3 As==01
    e83c:	b0 12 96 e7 	call	#59286		;#0xe796

0000e840 <.LVL34>:
    e840:	0a 93       	cmp	#0,	r10	;r3 As==00
    e842:	03 24       	jz	$+8      	;abs 0xe84a

0000e844 <.LVL35>:
    e844:	4d 43       	clr.b	r13		;
    e846:	0d 8c       	sub	r12,	r13	;
    e848:	0c 4d       	mov	r13,	r12	;

0000e84a <.L28>:
    e84a:	3a 41       	pop	r10		;
    e84c:	30 41       	ret			

0000e84e <.L32>:
    e84e:	4a 43       	clr.b	r10		;
    e850:	30 40 30 e8 	br	#0xe830		;

0000e854 <__mspabi_divu>:
    e854:	4e 43       	clr.b	r14		;
    e856:	b0 12 96 e7 	call	#59286		;#0xe796

0000e85a <.LVL39>:
    e85a:	30 41       	ret			

0000e85c <__mspabi_remu>:
    e85c:	5e 43       	mov.b	#1,	r14	;r3 As==01
    e85e:	b0 12 96 e7 	call	#59286		;#0xe796

0000e862 <.LVL41>:
    e862:	30 41       	ret			

0000e864 <__mspabi_func_epilog_7>:
    e864:	34 41       	pop	r4		;

0000e866 <__mspabi_func_epilog_6>:
    e866:	35 41       	pop	r5		;

0000e868 <__mspabi_func_epilog_5>:
    e868:	36 41       	pop	r6		;

0000e86a <__mspabi_func_epilog_4>:
    e86a:	37 41       	pop	r7		;

0000e86c <__mspabi_func_epilog_3>:
    e86c:	38 41       	pop	r8		;

0000e86e <__mspabi_func_epilog_2>:
    e86e:	39 41       	pop	r9		;

0000e870 <__mspabi_func_epilog_1>:
    e870:	3a 41       	pop	r10		;
    e872:	30 41       	ret			

0000e874 <__mspabi_srai_15>:
    e874:	0c 11       	rra	r12		;

0000e876 <__mspabi_srai_14>:
    e876:	0c 11       	rra	r12		;

0000e878 <__mspabi_srai_13>:
    e878:	0c 11       	rra	r12		;

0000e87a <__mspabi_srai_12>:
    e87a:	0c 11       	rra	r12		;

0000e87c <__mspabi_srai_11>:
    e87c:	0c 11       	rra	r12		;

0000e87e <__mspabi_srai_10>:
    e87e:	0c 11       	rra	r12		;

0000e880 <__mspabi_srai_9>:
    e880:	0c 11       	rra	r12		;

0000e882 <__mspabi_srai_8>:
    e882:	0c 11       	rra	r12		;

0000e884 <__mspabi_srai_7>:
    e884:	0c 11       	rra	r12		;

0000e886 <__mspabi_srai_6>:
    e886:	0c 11       	rra	r12		;

0000e888 <__mspabi_srai_5>:
    e888:	0c 11       	rra	r12		;

0000e88a <__mspabi_srai_4>:
    e88a:	0c 11       	rra	r12		;

0000e88c <__mspabi_srai_3>:
    e88c:	0c 11       	rra	r12		;

0000e88e <__mspabi_srai_2>:
    e88e:	0c 11       	rra	r12		;

0000e890 <__mspabi_srai_1>:
    e890:	0c 11       	rra	r12		;
    e892:	30 41       	ret			

0000e894 <.L11>:
    e894:	3d 53       	add	#-1,	r13	;r3 As==11
    e896:	0c 11       	rra	r12		;

0000e898 <__mspabi_srai>:
    e898:	0d 93       	cmp	#0,	r13	;r3 As==00
    e89a:	fc 23       	jnz	$-6      	;abs 0xe894
    e89c:	30 41       	ret			

0000e89e <__mspabi_sral_15>:
    e89e:	0d 11       	rra	r13		;
    e8a0:	0c 10       	rrc	r12		;

0000e8a2 <__mspabi_sral_14>:
    e8a2:	0d 11       	rra	r13		;
    e8a4:	0c 10       	rrc	r12		;

0000e8a6 <__mspabi_sral_13>:
    e8a6:	0d 11       	rra	r13		;
    e8a8:	0c 10       	rrc	r12		;

0000e8aa <__mspabi_sral_12>:
    e8aa:	0d 11       	rra	r13		;
    e8ac:	0c 10       	rrc	r12		;

0000e8ae <__mspabi_sral_11>:
    e8ae:	0d 11       	rra	r13		;
    e8b0:	0c 10       	rrc	r12		;

0000e8b2 <__mspabi_sral_10>:
    e8b2:	0d 11       	rra	r13		;
    e8b4:	0c 10       	rrc	r12		;

0000e8b6 <__mspabi_sral_9>:
    e8b6:	0d 11       	rra	r13		;
    e8b8:	0c 10       	rrc	r12		;

0000e8ba <__mspabi_sral_8>:
    e8ba:	0d 11       	rra	r13		;
    e8bc:	0c 10       	rrc	r12		;

0000e8be <__mspabi_sral_7>:
    e8be:	0d 11       	rra	r13		;
    e8c0:	0c 10       	rrc	r12		;

0000e8c2 <__mspabi_sral_6>:
    e8c2:	0d 11       	rra	r13		;
    e8c4:	0c 10       	rrc	r12		;

0000e8c6 <__mspabi_sral_5>:
    e8c6:	0d 11       	rra	r13		;
    e8c8:	0c 10       	rrc	r12		;

0000e8ca <__mspabi_sral_4>:
    e8ca:	0d 11       	rra	r13		;
    e8cc:	0c 10       	rrc	r12		;

0000e8ce <__mspabi_sral_3>:
    e8ce:	0d 11       	rra	r13		;
    e8d0:	0c 10       	rrc	r12		;

0000e8d2 <__mspabi_sral_2>:
    e8d2:	0d 11       	rra	r13		;
    e8d4:	0c 10       	rrc	r12		;

0000e8d6 <__mspabi_sral_1>:
    e8d6:	0d 11       	rra	r13		;
    e8d8:	0c 10       	rrc	r12		;
    e8da:	30 41       	ret			

0000e8dc <.L12>:
    e8dc:	3e 53       	add	#-1,	r14	;r3 As==11
    e8de:	0d 11       	rra	r13		;
    e8e0:	0c 10       	rrc	r12		;

0000e8e2 <__mspabi_sral>:
    e8e2:	0e 93       	cmp	#0,	r14	;r3 As==00
    e8e4:	fb 23       	jnz	$-8      	;abs 0xe8dc
    e8e6:	30 41       	ret			

0000e8e8 <__mspabi_srli_15>:
    e8e8:	12 c3       	clrc			
    e8ea:	0c 10       	rrc	r12		;

0000e8ec <__mspabi_srli_14>:
    e8ec:	12 c3       	clrc			
    e8ee:	0c 10       	rrc	r12		;

0000e8f0 <__mspabi_srli_13>:
    e8f0:	12 c3       	clrc			
    e8f2:	0c 10       	rrc	r12		;

0000e8f4 <__mspabi_srli_12>:
    e8f4:	12 c3       	clrc			
    e8f6:	0c 10       	rrc	r12		;

0000e8f8 <__mspabi_srli_11>:
    e8f8:	12 c3       	clrc			
    e8fa:	0c 10       	rrc	r12		;

0000e8fc <__mspabi_srli_10>:
    e8fc:	12 c3       	clrc			
    e8fe:	0c 10       	rrc	r12		;

0000e900 <__mspabi_srli_9>:
    e900:	12 c3       	clrc			
    e902:	0c 10       	rrc	r12		;

0000e904 <__mspabi_srli_8>:
    e904:	12 c3       	clrc			
    e906:	0c 10       	rrc	r12		;

0000e908 <__mspabi_srli_7>:
    e908:	12 c3       	clrc			
    e90a:	0c 10       	rrc	r12		;

0000e90c <__mspabi_srli_6>:
    e90c:	12 c3       	clrc			
    e90e:	0c 10       	rrc	r12		;

0000e910 <__mspabi_srli_5>:
    e910:	12 c3       	clrc			
    e912:	0c 10       	rrc	r12		;

0000e914 <__mspabi_srli_4>:
    e914:	12 c3       	clrc			
    e916:	0c 10       	rrc	r12		;

0000e918 <__mspabi_srli_3>:
    e918:	12 c3       	clrc			
    e91a:	0c 10       	rrc	r12		;

0000e91c <__mspabi_srli_2>:
    e91c:	12 c3       	clrc			
    e91e:	0c 10       	rrc	r12		;

0000e920 <__mspabi_srli_1>:
    e920:	12 c3       	clrc			
    e922:	0c 10       	rrc	r12		;
    e924:	30 41       	ret			

0000e926 <.L11>:
    e926:	3d 53       	add	#-1,	r13	;r3 As==11
    e928:	12 c3       	clrc			
    e92a:	0c 10       	rrc	r12		;

0000e92c <__mspabi_srli>:
    e92c:	0d 93       	cmp	#0,	r13	;r3 As==00
    e92e:	fb 23       	jnz	$-8      	;abs 0xe926
    e930:	30 41       	ret			

0000e932 <__mspabi_srll_15>:
    e932:	12 c3       	clrc			
    e934:	0d 10       	rrc	r13		;
    e936:	0c 10       	rrc	r12		;

0000e938 <__mspabi_srll_14>:
    e938:	12 c3       	clrc			
    e93a:	0d 10       	rrc	r13		;
    e93c:	0c 10       	rrc	r12		;

0000e93e <__mspabi_srll_13>:
    e93e:	12 c3       	clrc			
    e940:	0d 10       	rrc	r13		;
    e942:	0c 10       	rrc	r12		;

0000e944 <__mspabi_srll_12>:
    e944:	12 c3       	clrc			
    e946:	0d 10       	rrc	r13		;
    e948:	0c 10       	rrc	r12		;

0000e94a <__mspabi_srll_11>:
    e94a:	12 c3       	clrc			
    e94c:	0d 10       	rrc	r13		;
    e94e:	0c 10       	rrc	r12		;

0000e950 <__mspabi_srll_10>:
    e950:	12 c3       	clrc			
    e952:	0d 10       	rrc	r13		;
    e954:	0c 10       	rrc	r12		;

0000e956 <__mspabi_srll_9>:
    e956:	12 c3       	clrc			
    e958:	0d 10       	rrc	r13		;
    e95a:	0c 10       	rrc	r12		;

0000e95c <__mspabi_srll_8>:
    e95c:	12 c3       	clrc			
    e95e:	0d 10       	rrc	r13		;
    e960:	0c 10       	rrc	r12		;

0000e962 <__mspabi_srll_7>:
    e962:	12 c3       	clrc			
    e964:	0d 10       	rrc	r13		;
    e966:	0c 10       	rrc	r12		;

0000e968 <__mspabi_srll_6>:
    e968:	12 c3       	clrc			
    e96a:	0d 10       	rrc	r13		;
    e96c:	0c 10       	rrc	r12		;

0000e96e <__mspabi_srll_5>:
    e96e:	12 c3       	clrc			
    e970:	0d 10       	rrc	r13		;
    e972:	0c 10       	rrc	r12		;

0000e974 <__mspabi_srll_4>:
    e974:	12 c3       	clrc			
    e976:	0d 10       	rrc	r13		;
    e978:	0c 10       	rrc	r12		;

0000e97a <__mspabi_srll_3>:
    e97a:	12 c3       	clrc			
    e97c:	0d 10       	rrc	r13		;
    e97e:	0c 10       	rrc	r12		;

0000e980 <__mspabi_srll_2>:
    e980:	12 c3       	clrc			
    e982:	0d 10       	rrc	r13		;
    e984:	0c 10       	rrc	r12		;

0000e986 <__mspabi_srll_1>:
    e986:	12 c3       	clrc			
    e988:	0d 10       	rrc	r13		;
    e98a:	0c 10       	rrc	r12		;
    e98c:	30 41       	ret			

0000e98e <.L12>:
    e98e:	3e 53       	add	#-1,	r14	;r3 As==11
    e990:	12 c3       	clrc			
    e992:	0d 10       	rrc	r13		;
    e994:	0c 10       	rrc	r12		;

0000e996 <__mspabi_srll>:
    e996:	0e 93       	cmp	#0,	r14	;r3 As==00
    e998:	fa 23       	jnz	$-10     	;abs 0xe98e
    e99a:	30 41       	ret			

0000e99c <memmove>:
    e99c:	0d 9c       	cmp	r12,	r13	;
    e99e:	0a 28       	jnc	$+22     	;abs 0xe9b4

0000e9a0 <.L5>:
    e9a0:	0f 4c       	mov	r12,	r15	;
    e9a2:	0e 5c       	add	r12,	r14	;

0000e9a4 <.L3>:
    e9a4:	0e 9f       	cmp	r15,	r14	;
    e9a6:	0d 24       	jz	$+28     	;abs 0xe9c2

0000e9a8 <.LVL3>:
    e9a8:	ef 4d 00 00 	mov.b	@r13,	0(r15)	;
    e9ac:	1f 53       	inc	r15		;

0000e9ae <.LVL4>:
    e9ae:	1d 53       	inc	r13		;
    e9b0:	30 40 a4 e9 	br	#0xe9a4		;

0000e9b4 <.L2>:
    e9b4:	0f 4d       	mov	r13,	r15	;
    e9b6:	0f 5e       	add	r14,	r15	;
    e9b8:	0c 9f       	cmp	r15,	r12	;
    e9ba:	f2 2f       	jc	$-26     	;abs 0xe9a0

0000e9bc <.L4>:
    e9bc:	3e 53       	add	#-1,	r14	;r3 As==11

0000e9be <.LVL7>:
    e9be:	3e 93       	cmp	#-1,	r14	;r3 As==11
    e9c0:	01 20       	jnz	$+4      	;abs 0xe9c4

0000e9c2 <.L10>:
    e9c2:	30 41       	ret			

0000e9c4 <.L6>:
    e9c4:	0b 4c       	mov	r12,	r11	;
    e9c6:	0b 5e       	add	r14,	r11	;
    e9c8:	0f 4d       	mov	r13,	r15	;
    e9ca:	0f 5e       	add	r14,	r15	;
    e9cc:	eb 4f 00 00 	mov.b	@r15,	0(r11)	;
    e9d0:	30 40 bc e9 	br	#0xe9bc		;

0000e9d4 <memset>:
    e9d4:	0f 4c       	mov	r12,	r15	;
    e9d6:	0e 5c       	add	r12,	r14	;

0000e9d8 <.L2>:
    e9d8:	0f 9e       	cmp	r14,	r15	;
    e9da:	01 20       	jnz	$+4      	;abs 0xe9de

0000e9dc <.Loc.104.1>:
    e9dc:	30 41       	ret			

0000e9de <.L3>:
    e9de:	cf 4d 00 00 	mov.b	r13,	0(r15)	;
    e9e2:	1f 53       	inc	r15		;

0000e9e4 <.LVL4>:
    e9e4:	30 40 d8 e9 	br	#0xe9d8		;

0000e9e8 <L0>:
    e9e8:	30 41       	ret			

0000e9ea <__do_global_ctors_aux>:
    e9ea:	0a 12       	push	r10		;
    e9ec:	3a 40 20 e0 	mov	#57376,	r10	;#0xe020

0000e9f0 <.L2>:
    e9f0:	2c 4a       	mov	@r10,	r12	;
    e9f2:	3c 93       	cmp	#-1,	r12	;r3 As==11
    e9f4:	02 20       	jnz	$+6      	;abs 0xe9fa
    e9f6:	3a 41       	pop	r10		;
    e9f8:	30 41       	ret			

0000e9fa <.L3>:
    e9fa:	8c 12       	call	r12		;
    e9fc:	3a 50 fe ff 	add	#65534,	r10	;#0xfffe
    ea00:	30 40 f0 e9 	br	#0xe9f0		;

0000ea04 <call___do_global_ctors_aux>:
    ea04:	b0 12 2e e1 	call	#57646		;#0xe12e
    ea08:	b0 12 ea e9 	call	#59882		;#0xe9ea

0000ea0c <L0>:
    ea0c:	b0 12 66 e0 	call	#57446		;#0xe066

0000ea10 <.Loc.19.1>:
    ea10:	b0 12 58 e0 	call	#57432		;#0xe058

0000ea14 <.Loc.20.1>:
    ea14:	30 41       	ret			

0000ea16 <__msp430_fini>:
    ea16:	b0 12 74 e0 	call	#57460		;#0xe074

0000ea1a <L0>:
    ea1a:	b0 12 e0 e0 	call	#57568		;#0xe0e0

0000ea1e <L0>:
    ea1e:	30 41       	ret			
